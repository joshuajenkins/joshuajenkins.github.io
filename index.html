<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0 maximum-scale=5.0">
	<title>Joshua Jenkins</title>
	<style>
		@font-face {
		font-family: "Arnold";
		src: url("/fonts/Arnold_v0.3-Regular.woff2") format("woff2"),
			url("/fonts/Arnold_v0.3-Regular.woff") format("woff");
		}
		@font-face {
		font-family: "Arnold";
		src: url("/fonts/Arnold_v0.3-Italic.woff2") format("woff2"),
			url("/fonts/Arnold_v0.3-Italic.woff") format("woff");
		font-style: italic;
		}
		body {
			background: black;
			margin: 0;
			padding: 0;
			font-family: "Arnold", "system ui", sans-serf;
		}

		.grid {
			position: absolute;
			top: 0;
			left: 0;
			width: 50vw;
			height: 100vh;
			display: grid;
			grid-gap: 0;
		}
		.content {
			position: absolute;
			width: 50vw;
			height: 100vh;
			top: 0;
			left: 50vw;
			padding: 10%;
			box-sizing: border-box;
			overflow: auto;
		}

		@media (orientation: portrait) {
			.grid {
				width: 100vw;
				height: 50vh;
			}
			.content {
				width: 100vw;
				height: 100vh;
				left: 0;
				padding: 60vh 7.5% 15vh 7.5%;
				overflow: auto;
			}
		}

		.cell {
			background-color: black;
			transition: background-color 100ms linear;
		}
		.cell.on {
			background-color: #D2C297;
		}
		.intro {
			color: #D2C297;
			line-height: 24px;
			margin-bottom: 48px;
		}
		.intro .name {
			display: block;
			font-size: 16px;
			margin: 0;
			padding: 0;
			margin-bottom: 8px;
			font-weight: normal;
			font-style: italic;
		}
		.intro p {
			font-size: 16px;
			padding: 0;
			margin: 0;
		}
		.subsection {
			font-size: 20px;
			margin-bottom: 48px;
		}
		.subheading {
			margin: 0;
			padding: 0;
			font-size: 16px;
			line-height: 24px;
			margin-bottom: 8px;
			font-weight: normal;
			font-style: italic;
			color: #D2C297;
		}
		.linklist {
			list-style: none;
			padding: 0;
			margin: 0;
		}
		.linklist li {
			padding: 0;
			margin: 0;
			font-size: 14px;
			line-height: 24px;
			margin-bottom: 8px;
		}
		.linklist a:link, .linklist a:visited {
			color: #D2C297;
			text-decoration: none;
		}
		.linklist a:hover {
			text-decoration: underline;
		}
		.linklist li .date {
			font-size: 12px;
			font-style: italic;
			color: #D2C297;
			margin-left: 4px;
		}
		.img-wrapper {
			max-width: 50%;
			background-color: #D2C297;
			margin: 0;
			padding: 0;
		}
		.img {
			display: block;
			width: 100%;
			mix-blend-mode: multiply;
		}
	</style>
</head>
<body>
	<div class="content">
		<div class="intro">
			<p><span class="name">Joshua Jenkins</span></p>
			<p>Head of design at Snowflake. Shape &amp; texture choreographer. San Francisco based. You&rsquo;re viewing a website I made.</p>
		</div>

		<div class="subsection">
			<h2 class="subheading">Writing</h2>
			<ol class="linklist">
				<li>
					<a href="https://twitter.com/joshuajenkins/status/1227411521006784512">A balanced, rigorous analysis of data visualizations at a moment in time</a>
					<span class="date">Feb&nbsp;2020</span>
				</li>
				<li>
					<a href="https://reading.supply/@joshuajenkins/imitating-a-copier-evmvhD">Imitating a copier</a>
					<span class="date">Dec&nbsp;2019</span>
				</li>
			</ol>
		</div>

		<div class="subsection">
			<h2 class="subheading">Links</h2>
			<ol class="linklist">
				<li>
					<a href="https://twitter.com/joshuajenkins">Twitter</a>
				</li>
				<li>
					<a href="https://instagram.com/joshuajenkins">Instagram</a>
				</li>
			</ol>
		</div>

		<div class="subsection">
			<div class="img-wrapper">
				<img class="img" src="/professional-portrait.jpg" />
			</div>
		</div>
	</div>
	<div class="grid"></div>

	<script>
		/*
			ok so what I'm going to do here is figure out the viewport size
			and then make the squarest possible divisions within some size range
			I'm not going to worry about window resizing
		*/

		const isPortrait = window.innerHeight > window.innerWidth
		const width = isPortrait ? window.innerWidth : window.innerWidth / 2
		const height = isPortrait ? window.innerHeight / 2 : window.innerHeight
		const minSize = isPortrait ? 8 : 18
		const maxSize = isPortrait ? 14 : 24

		/*
			I don't actually know how to do figure this out mathematically,
			but one idea is to find the smallest possible remainder for each size
		*/

		let smallestRemainder = 2
		let bestSize
		for (let i = minSize; i < maxSize; i++) {
			const currSize = minSize + i
			const currRemainder = ((width / currSize) % 1) + ((height / currSize) % 1)
			if (currRemainder < smallestRemainder) {
				smallestRemainder = currRemainder
				bestSize = currSize
			}
		}

		/* now we need to convert the best size into number of divisions */

		const numRows = Math.round(height / bestSize)
		const numCols = Math.round(width / bestSize)

		/*
			now we construct the grid
			I have no doubt there's a better way to do this
			let me know if you think of one!
		*/

		const gridEl = document.getElementsByClassName("grid")[0]
		gridEl.setAttribute("style", `grid-template-columns: repeat(${numCols}, 1fr); grid-template-rows: repeat(${numRows}, 1fr)`);

		for (let i = 0; i < numRows; i++) {
			for (let j = 0; j < numCols; j++) {
				const cellEl = document.createElement("div")
				cellEl.classList.add("cell")
				gridEl.appendChild(cellEl)
			}
		}

		const cells = document.getElementsByClassName("cell")
		const rowColToIdx = (numRows, numCols, row, col) => numCols * row + col

		let activeInterval

		const routine1 = (cells, numRows, numCols) => {

			let flip = Math.random() > 0.5

			const render = () => {
				const cx = Math.round(Math.random() * numCols)
				const cy = Math.round(Math.random() * numRows)
				const stepDist = 1.75 + Math.random() * 2
				const thresh = Math.random() / 8

				const dist = (row, col) => Math.sqrt(Math.pow(cx - col, 2) + Math.pow(cy - row, 2))
				const isOn = (len) => ((len % stepDist <= thresh) || (len % stepDist >= (1 - thresh)))

				const newStates = []

				for (let i = 0; i < numRows; i++) {
					for (let j = 0; j < numCols; j++) {
						newStates.push(isOn(dist(i, j)))
					}
				}

				const transitionDuration = 1250
				const maxDist = numCols + numRows
				const numRounds = maxDist

				for (let n = 1; n < numRounds; n++) {
					setTimeout(() => {

						for (let i = 0; i < numRows; i++) {
							for (let j = 0; j < numCols; j++) {
								const cellDist = dist(i, j)
								const inRange = (cellDist <= maxDist * n / numRounds) && (cellDist >= maxDist * (n-1) / numRounds)
								
								if (inRange) {
									const idx = rowColToIdx(numRows, numCols, i, j)
									const cell = cells[idx]
									if (newStates[idx] === flip) {
										cell.classList.add("on")
									} else {
										cell.classList.remove("on")
									}
								}
							}
						}
					}, (transitionDuration / numRows) * n)
				}
				flip = !flip
			}
			render()
			activeInterval = setInterval(render, 3500)
		}

		routine1(cells, numRows, numCols)

	</script>
</body>
</html>