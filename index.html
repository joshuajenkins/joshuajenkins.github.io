<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0 maximum-scale=5.0">
	<title>Joshua Jenkins</title>
	<style>
		body {
			background: black;
			margin: 0;
			padding: 0;
			font-family: "Arnold_v0.3";
			/*font-style: italic;*/
		}

		.grid {
			position: absolute;
			top: 0;
			left: 0;
			width: 50vw;
			height: 100vh;
			display: grid;
			grid-gap: 0;
		}
		.content {
			position: absolute;
			width: 50vw;
			height: 100vh;
			top: 0;
			left: 50vw;
			padding: 10%;
			box-sizing: border-box;
		}

		@media (orientation: portrait) {
			.grid {
				width: 100vw;
				height: 50vh;
			}
			.content {
				width: 100vw;
				height: 100vh;
				left: 0;
				padding: 60vh 20% 15vh 20%;
				overflow: auto;
			}
		}

		.cell {
			background-color: black;
			transition: background-color 500ms ease;
		}
		.cell.on {
			background-color: #D2C297;
		}
		.intro {
			color: #D2C297;
			line-height: 24px;
			margin-bottom: 48px;
		}
		h1 {
			font-size: 16px;
			margin: 0;
			padding: 0;
			display: inline;
			font-weight: normal;
			font-style: italic;
		}
		.intro p {
			font-size: 16px;
			display: inline;
			padding: 0;
			margin: 0;
		}
		.recent {
			font-size: 20px;
		}
		.recent h2 {
			margin: 0;
			padding: 0;
			font-size: 16px;
			line-height: 24px;
			font-weight: normal;
			font-style: italic;
			color: #D2C297;
		}
		.recent ol {
			list-style: none;
			padding: 0;
			margin: 0;
		}
		.recent li {
			padding: 0;
			margin: 0;
			font-size: 14px;
			line-height: 24px;
		}
		.recent a:link, .recent a:visited {
			color: #D2C297;
			text-decoration: underline;
		}
		.recent li .date {
			display: inline-block;
			width: 72px;
			margin-left: -80px;
			font-size: 12px;
			font-style: italic;
			color: #aaa;
		}
	</style>
</head>
<body>
	<div class="grid"></div>
	<div class="content">
		<div class="intro">
			<h1>Joshua Jenkins</h1>
			<p> is the head of product design at Snowflake in the San Francisco Bay area and a practicing artist. Emphasis on practicing.</p>
		</div>

		<div class="recent">
			<h2>Writing</h2>
			<ol>
				<li>
					<span class="date">Dec 2019</span>
					<a href="https://reading.supply/@joshuajenkins/imitating-a-copier-evmvhD">Imitating a copier</a>
				</li>
			</ol>
		</div>
	</div>

	<script>
		/*
			ok so what I'm going to do here is figure out the viewport size
			and then make the squarest possible divisions within some size range
			I'm not going to worry about window resizing
		*/

		const isPortrait = window.innerHeight > window.innerWidth
		const width = isPortrait ? window.innerWidth : window.innerWidth / 2
		const height = isPortrait ? window.innerHeight / 2 : window.innerHeight
		const minSize = 18
		const maxSize = 24

		/*
			I don't actually know how to do figure this out mathematically,
			but one idea is to find the smallest possible remainder for each size
		*/

		let smallestRemainder = 2
		let bestSize
		for (let i = minSize; i < maxSize; i++) {
			const currSize = minSize + i
			const currRemainder = ((width / currSize) % 1) + ((height / currSize) % 1)
			if (currRemainder < smallestRemainder) {
				smallestRemainder = currRemainder
				bestSize = currSize
			}
		}

		/* now we need to convert the best size into number of divisions */

		const numRows = Math.round(height / bestSize)
		const numCols = Math.round(width / bestSize)

		/*
			now we construct the grid
			I have no doubt there's a better way to do this
			let me know if you think of one!
		*/

		const gridEl = document.getElementsByClassName("grid")[0]
		gridEl.setAttribute("style", `grid-template-columns: repeat(${numCols}, 1fr); grid-template-rows: repeat(${numRows}, 1fr)`);

		for (let i = 0; i < numRows; i++) {
			for (let j = 0; j < numCols; j++) {
				const cellEl = document.createElement("div")
				cellEl.classList.add("cell")
				gridEl.appendChild(cellEl)
			}
		}

		const cells = document.getElementsByClassName("cell")
		const numCells = cells.length

		const rowColToIdx = (numRows, numCols, row, col) => numCols * row + col

		const routine1 = (cells, numRows, numCols) => {

			let currIdx = 0
			let maxIdx = numRows + numCols

			setInterval(() => {
				for (let i = 0; i < numRows; i++) {
					for (let j = 0; j < numCols; j++) {
						const cell = cells[rowColToIdx(numRows, numCols, i, j)]
						if ((i + j) == currIdx) {
							cell.classList.add("on")
						} else {
							cell.classList.remove("on")
						}
					}
				}
				if (currIdx < maxIdx) {
					currIdx += 1
				} else {
					currIdx = 0
				}
			}, 500)
		}

		routine1(cells, numRows, numCols)

		// window.setInterval(() => {
		// 	if (Math.random() > 0.5) {
		// 		cells[Math.floor(Math.random() * numCells)].classList.toggle("on")
		// 	}
		// }, 20)

	</script>
</body>
</html>